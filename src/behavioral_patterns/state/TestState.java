package behavioral_patterns.state;

import behavioral_patterns.state.ui.Player;
import behavioral_patterns.state.ui.UI;

/*
Тип паттерна: поведенческий.
Шаги создания:
1. Определитесь с классом, который будет играть роль контекста. Это может быть как существующий класс,
   в котором уже есть зависимость от состояния, так и новый класс, если код состояний размазан по нескольким классам.
2. Создайте общий интерфейс состояний. Он должен описывать методы, общие для всех состояний, обнаруженных в контексте.
   Заметьте, что не всё поведение контекста нужно переносить в состояние, а только то, которое зависит от состояний.
3. Для каждого фактического состояния создайте класс, реализующий интерфейс состояния. Переместите код, связанный с
   конкретными состояниями в нужные классы. В конце концов, все методы интерфейса состояния должны быть реализованы
   во всех классах состояний.
4. При переносе поведения из контекста вы можете столкнуться с тем, что это поведение зависит от приватных полей или
   методов контекста, к которым нет доступа из объекта состояния. Существует парочка способов обойти эту проблему.
5. Самый простой — оставить поведение внутри контекста, вызывая его из объекта состояния. С другой стороны,
   вы можете сделать классы состояний вложенными в класс контекста, и тогда они получат доступ ко всем приватным
   частям контекста.
6. Создайте в контексте поле для хранения объектов-состояний, а также публичный метод для изменения значения этого поля.
7. Старые методы контекста, в которых находился зависимый от состояния код, замените на вызовы соответствующих
   методов объекта-состояния.
8. В зависимости от бизнес-логики, разместите код, который переключает состояние контекста либо внутри контекста,
   либо внутри классов конкретных состояний. (в данном примере код размещён внутри классов состояний).

Примеры использования:
javax.faces.lifecycle.LifeCycle#execute() (контролируемый из FacesServlet: поведение зависит
от текущей фазы (состояния) JSF)
Состояние сущности в PersistenceContext (Hibernate / JPA), жизненный цикл стрима.
 */
public class TestState {
    public static void main(String[] args) {
        Player player = new Player();
        UI ui = new UI(player);
        ui.init();

        String plus = """
                1. Избавляет от множества больших условных операторов машины состояний.
                2. Концентрирует в одном месте код, связанный с определённым состоянием.
                3. Упрощает код контекста.
                """;

        String minus = """
                1. Может неоправданно усложнить код, если состояний мало и они редко меняются.
                """;

        System.out.println("Плюсы:\n" + plus);
        System.out.println("Минусы:\n" + minus);
    }
}
