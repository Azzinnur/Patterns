package behavioral_patterns.observer;

import behavioral_patterns.observer.editor.FileEditor;
import behavioral_patterns.observer.listeners.EmailNotificationListener;
import behavioral_patterns.observer.listeners.LogOpenListener;
/*
Тип паттерна: поведенческий.
Шаги реализации:
1. Разбейте вашу функциональность на две части: независимое ядро и опциональные зависимые части. Независимое ядро
   станет издателем. Зависимые части станут подписчиками.
2. Создайте интерфейс подписчиков. Обычно в нём достаточно определить единственный метод оповещения.
3. Создайте интерфейс издателей и опишите в нём операции управления подпиской. Помните, что издатель должен работать
   только с общим интерфейсом подписчиков.
4. Вам нужно решить, куда поместить код ведения подписки, ведь он обычно бывает одинаков для всех типов издателей.
   Самый очевидный способ — вынести этот код в промежуточный абстрактный класс, от которого будут наследоваться
   все издатели.
5. Если вы интегрируете паттерн в существующие классы, то создать новый базовый класс может быть затруднительно.
   В этом случае вы можете поместить логику подписки во вспомогательный объект и делегировать ему работу из издателей.
6. Создайте классы конкретных издателей. Реализуйте их так, чтобы после каждого изменения состояния они отправляли
   оповещения всем своим подписчикам.
7. Реализуйте метод оповещения в конкретных подписчиках. Не забудьте предусмотреть параметры, через которые издатель
   мог бы отправлять какие-то данные, связанные с происшедшим событием.
8. Возможен и другой вариант, когда подписчик, получив оповещение, сам возьмёт из объекта издателя нужные данные.
   Но в этом случае вы будете вынуждены привязать класс подписчика к конкретному классу издателя.
9. Клиент должен создавать необходимое количество объектов подписчиков и подписывать их у издателей.

Примеры паттерна:
java.util.Observer/java.util.Observable (редко используется в реальной жизни)
Все реализации java.util.EventListener (практически во всём Swing-е)
javax.servlet.http.HttpSessionBindingListener
javax.servlet.http.HttpSessionAttributeListener
javax.faces.event.PhaseListener
Листенеры и интерсепторы в Spring и Hibernate.
 */
public class TestObserver {
    public static void main(String[] args) {
        FileEditor editor = new FileEditor();
        editor.getEvents().subscribe("open", new LogOpenListener("D:/logfile.txt"));
        editor.getEvents().subscribe("save", new EmailNotificationListener("admin@example.com"));

        try {
            editor.openFile("D:/OutputDemo.txt");
            editor.saveFile();
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println();
        String plus = """
                1. Издатели не зависят от конкретных классов подписчиков и наоборот.
                2. Вы можете подписывать и отписывать получателей на лету.
                3. Реализует принцип открытости/закрытости.
                """;

        String minus = """
                1. Подписчики оповещаются в случайном порядке.
                """;

        System.out.println("Плюсы:\n" + plus);
        System.out.println("Минусы:\n" + minus);
    }
}
